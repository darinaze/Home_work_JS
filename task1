
'number' + 3 + 3 // результат 'number33', бо якщо хоч одна частина виразу є рядком то інша приводиться до рядка і виконується операція конкатенація


null + 3 // результат 3, бо за правилами перетворення в число, null стає 0, 0+3=3

5 && "qwerty" // результат "qwerty", бо оператор або повертає другий операнд якщо перший true

+'40' + +'2' + "hillel"; // результат строка "42hillel", унарний + перетворив 40 та 2 на число, виконалась канкатенація бо один з операндів рядок

'10' - 5 === 6; // результат false, спочатку математична операція з автоматичним перетворенням строки в число, і строге порівняння число 5 не дорівнює числу 6

true + false // результат 1, бо під час перетворення в число при арифметичній операції true це 1 а false це 0

'4px' - 3 // результат NaN, при перетворенні в число рядок'4px' стає NaN, а будб-які операції з NaN повертають NaN

'4' - 3 // результат 1, строка автоматично перетворилась на 4 та виконалось віднімання чисел

'6' + 3 ** 0; // результат '61', спочатку операція піднесення до степені а потім операція конкатенація, так як у нас присутня строка

12 / '6'// результат 2, спочатку приведення строки в число а потім ділення

'10' + (5 === 6)// результат '10false', спочатку операція з вищім пріоритетом а потім операція канкатенації;

null == ''  // результат false, бо null нічому не дорівнює

3 ** (9 / 3) ; // результат 27, спочатку ділення бо групування має найвищій пріоритет а потім приведення до степеню 

!!'false' == !!'true' //результат true, рядок завжди тру, оператор подвійне Не перетворює тру, на тру, тру дорівнює тру

0 || '0' && 1 // результат 1, логічне і вище по пріоритету, рядок з нулем є тру, логічне і повертає другий операнд якщо перший тру, виводиться 1 бо перше фолс

(+null == false) < 1; // результат false, спочатку операція групування, перетворення null це 0, порівняння

false && true || true // результат true, логічне і має більший пріоритет тому спочатку ця операція, а логічне або повертає тру, коли хоча б один з операндів є тру

false && (false || true);// результат false, операцяя групування має вищій пріоритет тому спочатку виконується операція або, логічне і повертає тру якщо всі операнди є тру 

(+null == false) < 1 ** 5;// результат false , спочатку операція групування, нуль дорівнює нулю, потім приведення до степені а потім порівняння